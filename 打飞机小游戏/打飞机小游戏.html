<html>
    <head>
        <title>airplane 虽然现在打飞机游戏在网上有很多文章教你怎么实现，但能否不看这些文章基于自己的现有知识点去拆解功能实现你自己的打飞机游戏呢？</title>
        <style>
            .wrapper,
            .container{
                position: relative;
                width: 100w;
                height: 100vh;
                background: #ccc;
                overflow: hidden;
            }
            .airplane{
                position: absolute;
                width: 50px;
                height: 50px;
            }
            .forward{
                top: 0;
                transform: rotate(180deg);
                display: none;
                /* animation: move 10s linear infinite; */
            }
            .guard{
                bottom: 0;
                left: 40%
            }
            body{
                margin: 0;
                padding: 0;
            }
            
            .score{
                font-size: 20px;
            }
            .bullet{
                position: absolute;
                z-index: 10;
                width: 10px;
                height: 30px;
                border-radius: 10px;
                background: red;
            }
            /* 敌机动画，一直重复从上到下的运动过程 */
            @keyframes move{
                0% {
                    top: 0;
                }
                100% {
                    top: 100vh;
                }
            }
        </style>
    </head>
    <body>
        <!-- <div class="wrapper"> -->
            <div class="container">
                <img src="./assets/airplane.jpg" class="airplane forward attack"/>
                <img src="./assets/airplane.jpg" class="airplane forward attack"/>
                <img src="./assets/airplane.jpg" class="airplane forward attack"/>
                <img src="./assets/airplane.jpg" class="airplane forward attack"/>
                <img src="./assets/airplane.jpg" class="airplane forward attack"/>
                <img src="./assets/airplane.jpg" class="airplane forward attack"/>
                <img src="./assets/airplane.jpg" class="airplane forward attack"/>
                <img src="./assets/airplane.jpg" class="airplane forward attack"/>

                <img src="./assets/airplane.jpg" class="airplane guard"/>
                
                <button onClick="restart()">重新开始</button>
                <div class="score"></div>
            </div>
        <!-- </div> -->

        <script>
            /**
             *  难点：
             *  1、飞机可以点击拖动
             *  2、敌机随机在水平线上出现  x = random 
             *  3、敌机竖直移动，判断是否撞机  window.requestAnimationFrame
             *  4、游戏结束：敌机与飞机碰撞，判断依据为飞机与敌机在 竖直方向上有重叠时，水平方向上也有重叠，则为碰撞。
             * 
             *  5、子弹发射方向、碰到敌机后 或者消失在视野上时 可以再生成。
             *  6、子弹发射后，移动飞机，不改变已发射子弹的运动轨迹
             */
            let container = document.querySelector('.container')
            let attackList = document.querySelectorAll('.attack')
            let scoreDom =  document.querySelector('.score')
            let guard = document.querySelector('.guard');
            guard._moved = false

            let bulletList = []
            let score = 0
            let { vw, vh } = getViewport()
            
            let guardRect = guard.getBoundingClientRect()
            // 游戏结束
            let isOver = false

            // 重新开始
            const restart = () => { location.reload() }
            function getViewport() {
                return {
                    vw: document.body.clientWidth || document.documentElement.clientWidth,
                    vh: document.body.clientHeight || document.documentElement.clientHeight
                }
            }
            window.addEventListener('resize', () => { vm = getViewport(); vw = vm.vw; vh = vm.vh })

            setScore()
            function setScore() {
                scoreDom.textContent = score
            }
            
            // 射击
            // 子弹数量
            let capacity = 15
            createBullet(capacity)
            function createBullet(capacity) {
                for(let i = 0; i < capacity; i++) {
                    let bullet = document.createElement('div')
                        bullet.setAttribute('class', 'bullet')
                        document.body.appendChild(bullet)
                        bulletList.push(bullet)
                }
                beforeShoot()
            }
            function beforeShoot() {
                for(let i = 0; i < bulletList.length; i++) {
                    setTimeout(() => {
                        let bullet = bulletList[i]
                        if(guard._moved) {
                            guardRect = { top: parseFloat(guard.style.top), left: parseFloat(guard.style.left) }
                        }
                        bullet.style.top = guardRect.top;
                        bullet.style.left = guardRect.left + 20;
                        shoot(bullet, guardRect.top || vh)
                    }, i * 300)
                }
            }
            function shoot(ele, top) {
                
                const node = ele
                let start, previousTimeStamp;
                
                function step(timestamp) {

                    if (isOver) return

                    if (start === undefined) {
                        start = timestamp;
                    }

                    const elapsed = timestamp - start;
                    if (previousTimeStamp !== timestamp) {
                        
                        // shoot speed
                        const count = Math.min(1 * elapsed, top);
                        
                        node.style.top = ((top-count-30) % top)+'px'
                        
                        // 到顶，需要重置
                        if( count === top ) {
                            start = timestamp
                            top = guardRect.top
                            moveEl(node, guardRect.left, guardRect.top)
                        }

                        // 子弹击中飞机，分数加1，重置飞机和子弹位置
                        attackList.forEach(attack => {
                            if(shootTarget(ele, attack)) {
                                top = guardRect.top
                                moveEl(node, guardRect.left, top)

                                setScore(++score)

                                attack._knocked = true
                                attack.style.display = "none"
                            }
                        })
                        
                    }
                    previousTimeStamp = timestamp
                    window.requestAnimationFrame(step);
                }

                window.requestAnimationFrame(step);
            
            }

            function shootTarget(bullet, target) {
                let bt = parseFloat(bullet.style.top), bl = parseFloat(bullet.style.left)
                let tt = parseFloat(target.style.top), tl = parseFloat(target.style.left)
    
                if((bl >= tl && bl <= tl+50)) {
                    
                    return (tt+50 >= bt && bt <= tt)
                }
                return false
            }

            // 敌机与飞机发生碰撞，游戏结束
            function isKnock(e1,e2 = guard) {
                let rect1 = e1.getBoundingClientRect()
                let rect2 = e2.getBoundingClientRect()
                let l1 = rect1.left, t1 = rect1.top
                let l2 = rect2.left, t2 = rect2.top

                // 飞机与敌机在竖直方向上有重叠 && 水平方向上也有重叠
                if(t1+50 >= t2 && t1 <= t2+50) {
                    isOver = (l2 >= l1 && l2 < l1+50) || (l2+50 >= l1 && l2+50 <= l1+50) //(t2+50 >= t1) && 
                    return true
                }
                return false
            }


            
            random()
            function random() {
                attackList.forEach((el,index) => setTimeout(() => {
                    if(!isOver) {
                        moveEl(el, Math.random() * vw, 0)
                        mov(el)
                    }
                }, 1000 * index))
            }

            function mov(ele) {
                if(!ele._block) {
                    ele._block = true
                    ele.style.display ="block"
                }
                
                const element = ele
                let start, previousTimeStamp;

                function step(timestamp) {
                    if(isOver) return

                    if (start === undefined) {
                        start = timestamp;
                    }

                    const elapsed = timestamp - start;

                    if (previousTimeStamp !== timestamp) {
                        
                        // 飞机飞行速度控制
                        const count = Math.min(0.5 * elapsed - 100, vh);
                        element.style.top = (count % vh)+'px'
                        
                        isKnock(element)
                        if(element._knocked) {
                            start = timestamp
                            setTimeout(() => {
                                element.style.display = "block"
                                moveEl(element, Math.random() * vw, 0)
                                element._knocked = false
                            }, 0)
                            
                        }
                        // 到底重置
                        if (count === vh) {
                            top = -100
                            start = timestamp
                            moveEl(element, Math.random() * vw, -100)
                        }
                    }
                    previousTimeStamp = timestamp
                    window.requestAnimationFrame(step);
                }

                window.requestAnimationFrame(step);
            }
            
            
            function moveEl(el, left, top) {
                if(left + 50 >= vw) {
                    el.style.left = (vw -50) + 'px'
                } else {
                    el.style.left = left + 'px'
                }
                el.style.top = top + 'px'
            }
            // pc端
            container.addEventListener('mousedown', mousedown)
            function mousedown(e) {
                e.preventDefault()
                container.addEventListener('mousemove', mousemove)
                container.addEventListener('mouseup', mouseup)
                let ox = e.pageX,oy = e.pageY, mx, my, dx, dy
                function mouseup(e) {
                    container.removeEventListener('mousemove', mousemove)
                    container.removeEventListener('mouseup', mouseup)
                    guard._moved = false
                }
                function mousemove(e) {
                    mx = e.pageX
                    my = e.pageY
                    dx = mx - ox
                    dy = my - oy
                    moveEl(guard, dx+ox, dy+oy)
                    guard._moved = true
                    guardRect = guard.getBoundingClientRect()
                }
                
            }

        </script>
    </body>
</html>